<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Inversion Test - Step by Step</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .test-section h2 {
            margin-top: 0;
            color: #333;
        }
        .test-block {
            width: 200px;
            height: 200px;
            margin: 20px;
            display: inline-block;
            border: 2px solid #333;
            position: relative;
        }
        .test-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
        }
        .debug-info {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            border-left: 3px solid #007bff;
            white-space: pre-wrap;
        }
        .navbar-test {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-bottom: 2px solid #333;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .navbar-test a {
            margin: 0 15px;
            text-decoration: none;
            font-weight: bold;
            font-size: 18px;
        }
        .spacer {
            height: 400px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px;
        }
    </style>
</head>
<body>
    <!-- Test navbar that will sample colors -->
    <div class="navbar-test" id="test-navbar">
        <a href="#" id="nav-link-1">Home</a>
        <a href="#" id="nav-link-2">About</a>
        <a href="#" id="nav-link-3">Contact</a>
    </div>
    
    <div class="spacer"></div>
    
    <!-- Step 1: Test color inversion function -->
    <div class="test-section">
        <h2>Step 1: Test Color Inversion Function</h2>
        <p>Testing if inversion works correctly. Expected: Blue→Orange, Green→Magenta, Purple→Yellow</p>
        
        <div class="test-block" style="background-color: #0000ff;">
            <div class="test-text" id="blue-text">BLUE</div>
        </div>
        
        <div class="test-block" style="background-color: #00ff00;">
            <div class="test-text" id="green-text">GREEN</div>
        </div>
        
        <div class="test-block" style="background-color: #8800ff;">
            <div class="test-text" id="purple-text">PURPLE</div>
        </div>
        
        <div class="debug-info" id="step1-debug"></div>
    </div>
    
    <!-- Step 2: Test color sampling from DOM -->
    <div class="test-section">
        <h2>Step 2: Test Color Sampling from DOM</h2>
        <p>Click buttons to test sampling colors from elements with inline styles</p>
        <button onclick="testSampleBlue()">Sample Blue Block</button>
        <button onclick="testSampleGreen()">Sample Green Block</button>
        <button onclick="testSamplePurple()">Sample Purple Block</button>
        <div class="debug-info" id="step2-debug">Click a button to test sampling...</div>
        
        <div class="test-block" style="background-color: #0000ff; margin-top: 20px;" id="blue-block">
            <div class="test-text" style="color: white;">BLUE BLOCK</div>
        </div>
        
        <div class="test-block" style="background-color: #00ff00; margin-top: 20px;" id="green-block">
            <div class="test-text" style="color: black;">GREEN BLOCK</div>
        </div>
        
        <div class="test-block" style="background-color: #8800ff; margin-top: 20px;" id="purple-block">
            <div class="test-text" style="color: white;">PURPLE BLOCK</div>
        </div>
    </div>
    
    <!-- Step 3: Test point sampling -->
    <div class="test-section">
        <h2>Step 3: Test Point Sampling (elementFromPoint)</h2>
        <p>Click on a color block to sample the color at that exact point</p>
        <div class="debug-info" id="step3-debug">Click on a color block below...</div>
        
        <div class="test-block" style="background-color: #ff0000; cursor: pointer;" onclick="testPointSample(event)">
            <div class="test-text" style="color: white;">RED (click me)</div>
        </div>
        
        <div class="test-block" style="background-color: #00ff00; cursor: pointer;" onclick="testPointSample(event)">
            <div class="test-text" style="color: black;">GREEN (click me)</div>
        </div>
        
        <div class="test-block" style="background-color: #0000ff; cursor: pointer;" onclick="testPointSample(event)">
            <div class="test-text" style="color: white;">BLUE (click me)</div>
        </div>
    </div>
    
    <!-- Step 4: Test scrolling and live sampling -->
    <div class="test-section">
        <h2>Step 4: Test Scrolling & Live Sampling</h2>
        <p>Scroll to move the navbar over different color blocks. Watch the debug info update.</p>
        <button onclick="startLiveSampling()">Start Live Sampling</button>
        <button onclick="stopLiveSampling()">Stop Live Sampling</button>
        <div class="debug-info" id="step4-debug">Click 'Start Live Sampling' then scroll...</div>
        
        <div class="test-block" style="background-color: #ff0000;">
            <div class="test-text" style="color: white;">RED</div>
        </div>
        
        <div class="test-block" style="background-color: #00ff00;">
            <div class="test-text" style="color: black;">GREEN</div>
        </div>
        
        <div class="test-block" style="background-color: #0000ff;">
            <div class="test-text" style="color: white;">BLUE</div>
        </div>
        
        <div class="test-block" style="background-color: #8800ff;">
            <div class="test-text" style="color: white;">PURPLE</div>
        </div>
        
        <div class="test-block" style="background-color: #88ff00;">
            <div class="test-text" style="color: black;">CHARTREUSE</div>
        </div>
    </div>

    <script>
        // Utility functions
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Color inversion function (HSL-based, proven to work)
        function invertColor(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            // Calculate saturation
            const d = max - min;
            s = max === min ? 0 : (l > 0.5 ? d / (2 - max - min) : d / (max + min));
            
            // Check if this is a middle-tone gray (low saturation, medium lightness)
            // Middle-tone grays have no hue, so hue rotation doesn't help - force black/white
            if (s < 0.1 && l >= 0.4 && l <= 0.6) {
                // Middle-tone gray - choose black or white based on which has better contrast
                // Use relative luminance to determine contrast
                const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                // If original is closer to white (luminance > 0.5), use black; otherwise white
                return luminance > 0.5 ? { r: 0, g: 0, b: 0 } : { r: 255, g: 255, b: 255 };
            }
            
            // For pure grays (no saturation at all)
            if (max === min) {
                const invertedL = 1 - l;
                const gray = Math.round(invertedL * 255);
                return { r: gray, g: gray, b: gray };
            }
            
            // Calculate hue for colored colors
            switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
            }
            
            // Rotate hue by 180° for complement
            h = (h * 360 + 180) % 360;
            
            // For blue specifically (hue ~240°), ensure we get orange (~60°) not yellow
            // Blue (240°) + 180° = 420° = 60° (yellow-orange)
            // But we want more orange, so adjust slightly
            if (h >= 55 && h <= 65) {
                // This is yellow-orange range, push it more toward orange
                h = 30; // Pure orange
            }
            
            s = 1.0; // Max saturation for vibrant colors
            l = l > 0.5 ? 0.35 : 0.65; // Slightly adjust lightness for better color visibility
            
            // Convert back to RGB
            h = h / 360;
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            let r2, g2, b2;
            if (s === 0) {
                r2 = g2 = b2 = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r2 * 255),
                g: Math.round(g2 * 255),
                b: Math.round(b2 * 255)
            };
        }
        
        // Parse color from CSS string - FIXED to handle #0000ff correctly
        function parseColor(colorStr) {
            if (!colorStr || colorStr === 'transparent' || colorStr === 'rgba(0, 0, 0, 0)') {
                return null;
            }
            
            // Trim whitespace
            colorStr = colorStr.trim();
            
            // Handle rgb/rgba
            const rgbMatch = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch) {
                return {
                    r: parseInt(rgbMatch[1], 10),
                    g: parseInt(rgbMatch[2], 10),
                    b: parseInt(rgbMatch[3], 10),
                    alpha: 1
                };
            }
            
            // Handle hex - CRITICAL: match 6-digit hex FIRST, then 3-digit
            // The order matters! If we put 3-digit first, #0000ff matches as #000
            const hexMatch6 = colorStr.match(/#([0-9a-f]{6})(?:\s|;|$)/i);
            if (hexMatch6) {
                const hex = hexMatch6[1];
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                
                if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                    return { r: r, g: g, b: b, alpha: 1 };
                }
            }
            
            // Try 3-digit hex
            const hexMatch3 = colorStr.match(/#([0-9a-f]{3})(?:\s|;|$)/i);
            if (hexMatch3) {
                const hex3 = hexMatch3[1];
                // Expand 3-digit to 6-digit
                const hex = hex3.split('').map(c => c + c).join('');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                
                if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                    return { r: r, g: g, b: b, alpha: 1 };
                }
            }
            
            return null;
        }
        
        // Get color from inline style - improved to handle all cases
        function getColorFromInlineStyle(element) {
            if (!element) return null;
            const inlineStyle = element.getAttribute('style');
            if (!inlineStyle) return null;
            
            // Look for background-color specifically - match more carefully
            const bgColorMatch = inlineStyle.match(/background-color\s*:\s*([^;]+?)(?:\s*;|$)/i);
            if (bgColorMatch) {
                const colorStr = bgColorMatch[1].trim();
                // Debug: log what we're trying to parse
                console.log('Parsing color string:', colorStr, 'from style:', inlineStyle);
                const rgb = parseColor(colorStr);
                if (rgb && rgb.alpha > 0) {
                    console.log('Parsed to RGB:', rgb);
                    return { r: rgb.r, g: rgb.g, b: rgb.b };
                } else {
                    console.log('Failed to parse color:', colorStr);
                }
            }
            
            // Also check for just "background:" (less specific but might catch some cases)
            const bgMatch = inlineStyle.match(/background\s*:\s*([^;]+)/i);
            if (bgMatch) {
                const colorStr = bgMatch[1].trim();
                // Skip if it's a gradient
                if (!colorStr.includes('gradient') && !colorStr.includes('url')) {
                    const rgb = parseColor(colorStr);
                    if (rgb && rgb.alpha > 0) {
                        return { r: rgb.r, g: rgb.g, b: rgb.b };
                    }
                }
            }
            
            return null;
        }
        
        // Get background color traversing up DOM - CRITICAL: must find inline background-color
        function getBackgroundColor(element) {
            if (!element) return { r: 255, g: 255, b: 255 };
            
            // FIRST: Traverse up the entire tree looking for inline background-color
            // This is the most reliable way to get colors from color blocks
            let current = element;
            while (current && current !== document.body && current !== document.documentElement && current !== null) {
                const inlineColor = getColorFromInlineStyle(current);
                if (inlineColor) {
                    // Found inline color - return it immediately
                    return inlineColor;
                }
                current = current.parentElement;
            }
            
            // SECOND: If no inline style found, check computed styles
            // But be careful - computed styles might be inherited or default
            current = element;
            while (current && current !== document.body && current !== document.documentElement && current !== null) {
                const style = window.getComputedStyle(current);
                const bgColor = style.backgroundColor;
                const rgb = parseColor(bgColor);
                
                // Only use if it's a real color (not transparent, not black/white defaults)
                if (rgb && rgb.alpha > 0.95) {
                    // Skip black and white as they're likely defaults
                    const isBlack = rgb.r === 0 && rgb.g === 0 && rgb.b === 0;
                    const isWhite = rgb.r === 255 && rgb.g === 255 && rgb.b === 255;
                    if (!isBlack && !isWhite) {
                        return { r: rgb.r, g: rgb.g, b: rgb.b };
                    }
                }
                current = current.parentElement;
            }
            
            // Fallback to white
            return { r: 255, g: 255, b: 255 };
        }
        
        // STEP 1: Test inversion function
        function testStep1() {
            const blueText = document.getElementById('blue-text');
            const greenText = document.getElementById('green-text');
            const purpleText = document.getElementById('purple-text');
            const debug = document.getElementById('step1-debug');
            
            const blueInverted = invertColor(0, 0, 255);
            const greenInverted = invertColor(0, 255, 0);
            const purpleInverted = invertColor(136, 0, 255);
            
            blueText.style.color = rgbToHex(blueInverted.r, blueInverted.g, blueInverted.b);
            greenText.style.color = rgbToHex(greenInverted.r, greenInverted.g, greenInverted.b);
            purpleText.style.color = rgbToHex(purpleInverted.r, purpleInverted.g, purpleInverted.b);
            
            debug.textContent = `Blue (0,0,255) → ${rgbToHex(blueInverted.r, blueInverted.g, blueInverted.b)} (RGB: ${blueInverted.r},${blueInverted.g},${blueInverted.b})\n` +
                              `Green (0,255,0) → ${rgbToHex(greenInverted.r, greenInverted.g, greenInverted.b)} (RGB: ${greenInverted.r},${greenInverted.g},${greenInverted.b})\n` +
                              `Purple (136,0,255) → ${rgbToHex(purpleInverted.r, purpleInverted.g, purpleInverted.b)} (RGB: ${purpleInverted.r},${purpleInverted.g},${purpleInverted.b})`;
        }
        
        // STEP 2: Test sampling from DOM
        function testSampleBlue() {
            const block = document.getElementById('blue-block');
            const debug = document.getElementById('step2-debug');
            const color = getBackgroundColor(block);
            const inverted = invertColor(color.r, color.g, color.b);
            
            debug.textContent = `Sampled from blue block:\n` +
                              `  Element: ${block.tagName} with style="${block.getAttribute('style')}"\n` +
                              `  Inline color found: ${getColorFromInlineStyle(block) ? 'YES' : 'NO'}\n` +
                              `  Sampled RGB: (${color.r}, ${color.g}, ${color.b})\n` +
                              `  Sampled hex: ${rgbToHex(color.r, color.g, color.b)}\n` +
                              `  Inverted RGB: (${inverted.r}, ${inverted.g}, ${inverted.b})\n` +
                              `  Inverted hex: ${rgbToHex(inverted.r, inverted.g, inverted.b)}`;
        }
        
        function testSampleGreen() {
            const block = document.getElementById('green-block');
            const debug = document.getElementById('step2-debug');
            const color = getBackgroundColor(block);
            const inverted = invertColor(color.r, color.g, color.b);
            
            debug.textContent = `Sampled from green block:\n` +
                              `  Element: ${block.tagName} with style="${block.getAttribute('style')}"\n` +
                              `  Inline color found: ${getColorFromInlineStyle(block) ? 'YES' : 'NO'}\n` +
                              `  Sampled RGB: (${color.r}, ${color.g}, ${color.b})\n` +
                              `  Sampled hex: ${rgbToHex(color.r, color.g, color.b)}\n` +
                              `  Inverted RGB: (${inverted.r}, ${inverted.g}, ${inverted.b})\n` +
                              `  Inverted hex: ${rgbToHex(inverted.r, inverted.g, inverted.b)}`;
        }
        
        function testSamplePurple() {
            const block = document.getElementById('purple-block');
            const debug = document.getElementById('step2-debug');
            const color = getBackgroundColor(block);
            const inverted = invertColor(color.r, color.g, color.b);
            
            debug.textContent = `Sampled from purple block:\n` +
                              `  Element: ${block.tagName} with style="${block.getAttribute('style')}"\n` +
                              `  Inline color found: ${getColorFromInlineStyle(block) ? 'YES' : 'NO'}\n` +
                              `  Sampled RGB: (${color.r}, ${color.g}, ${color.b})\n` +
                              `  Sampled hex: ${rgbToHex(color.r, color.g, color.b)}\n` +
                              `  Inverted RGB: (${inverted.r}, ${inverted.g}, ${inverted.b})\n` +
                              `  Inverted hex: ${rgbToHex(inverted.r, inverted.g, inverted.b)}`;
        }
        
        // STEP 3: Test point sampling
        function testPointSample(event) {
            const debug = document.getElementById('step3-debug');
            const x = event.clientX;
            const y = event.clientY;
            
            const hitElement = document.elementFromPoint(x, y);
            
            // Debug: show the traversal
            let debugInfo = `Clicked at (${x}, ${y}):\n`;
            debugInfo += `  Hit element: ${hitElement.tagName}${hitElement.id ? ' #' + hitElement.id : ''}${hitElement.className ? ' .' + hitElement.className : ''}\n`;
            debugInfo += `  Hit element style: "${hitElement.getAttribute('style') || 'none'}"\n`;
            
            // Show parent chain
            let current = hitElement;
            let depth = 0;
            while (current && current !== document.body && depth < 5) {
                const inlineColor = getColorFromInlineStyle(current);
                debugInfo += `  Parent ${depth}: ${current.tagName}${current.id ? ' #' + current.id : ''} - style: "${(current.getAttribute('style') || 'none').substring(0, 50)}" - inline color: ${inlineColor ? rgbToHex(inlineColor.r, inlineColor.g, inlineColor.b) : 'NONE'}\n`;
                current = current.parentElement;
                depth++;
            }
            
            const color = getBackgroundColor(hitElement);
            const inverted = invertColor(color.r, color.g, color.b);
            
            debugInfo += `\n  FINAL RESULT:\n`;
            debugInfo += `  Sampled RGB: (${color.r}, ${color.g}, ${color.b})\n`;
            debugInfo += `  Sampled hex: ${rgbToHex(color.r, color.g, color.b)}\n`;
            debugInfo += `  Inverted RGB: (${inverted.r}, ${inverted.g}, ${inverted.b})\n`;
            debugInfo += `  Inverted hex: ${rgbToHex(inverted.r, inverted.g, inverted.b)}`;
            
            debug.textContent = debugInfo;
        }
        
        // STEP 4: Live sampling on scroll
        let liveSamplingInterval = null;
        
        function startLiveSampling() {
            if (liveSamplingInterval) return;
            
            const navbar = document.getElementById('test-navbar');
            const link = document.getElementById('nav-link-3'); // "Contact"
            const debug = document.getElementById('step4-debug');
            
            function sample() {
                const rect = link.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const hitElement = document.elementFromPoint(centerX, centerY);
                if (hitElement === navbar || navbar.contains(hitElement)) return;
                
                const color = getBackgroundColor(hitElement);
                const inverted = invertColor(color.r, color.g, color.b);
                
                link.style.color = rgbToHex(inverted.r, inverted.g, inverted.b);
                
                debug.textContent = `Sampling "Contact" link at (${Math.round(centerX)}, ${Math.round(centerY)}):\n` +
                                  `  Hit element: ${hitElement.tagName}${hitElement.id ? ' #' + hitElement.id : ''}\n` +
                                  `  Element style: "${(hitElement.getAttribute('style') || '').substring(0, 50)}..."\n` +
                                  `  Inline color: ${getColorFromInlineStyle(hitElement) ? 'YES' : 'NO'}\n` +
                                  `  Sampled: ${rgbToHex(color.r, color.g, color.b)} (${color.r},${color.g},${color.b})\n` +
                                  `  Inverted: ${rgbToHex(inverted.r, inverted.g, inverted.b)} (${inverted.r},${inverted.g},${inverted.b})`;
            }
            
            liveSamplingInterval = setInterval(sample, 100);
            sample(); // Run immediately
        }
        
        function stopLiveSampling() {
            if (liveSamplingInterval) {
                clearInterval(liveSamplingInterval);
                liveSamplingInterval = null;
            }
        }
        
        // Run Step 1 on load
        window.addEventListener('DOMContentLoaded', testStep1);
    </script>
</body>
</html>
